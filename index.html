<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-webpack/webpack学习笔记 （下）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/webpack/webpack学习笔记 （下）/" class="article-date">
  <time datetime="2017-05-24T14:01:51.390Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="webpack-学习笔记（下）"><a href="#webpack-学习笔记（下）" class="headerlink" title="webpack 学习笔记（下）"></a>webpack 学习笔记（下）</h1><h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p>对于一个大型的 Webapp 来说，把所有 JS 文件都放在同一个文件中是肯定不合理的！这会大大影响它的性能。webpack 允许我们把代码分割成几块。如果一些代码仅会在一些特定的情况下才执行时，webpack 会按需加载他们。</p>
<h4 id="require-ensure"><a href="#require-ensure" class="headerlink" title="require.ensure"></a>require.ensure</h4><p>我们可以使用 <code>require.ensure</code> 来定义一个分割点来实现代码分割。如下实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// main.js</div><div class="line">document.write(&apos;I will perform right now&apos;)</div><div class="line">setTimeout(function()&#123;</div><div class="line">	require.ensure([&apos;./a&apos;], function(require) &#123;</div><div class="line">	  var content = require(&apos;./a&apos;);</div><div class="line">	  document.open();</div><div class="line">	  document.write(content);</div><div class="line">	  document.close();</div><div class="line">	&#125;);</div><div class="line">&#125;, 3000)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// a.js</div><div class="line">module.exports = &apos;I will perform in 3 seconds.&apos;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// webpack.config.js</div><div class="line">module.exports = &#123;</div><div class="line">  entry: &apos;./index.js&apos;,</div><div class="line">  output: &#123;</div><div class="line">    filename: &apos;bundle.js&apos;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>webpack.config.js</code> 不需要做任何特殊处理，我们会发现 webpack 打包生成了两个文件 <code>bundle.js</code> 和 <code>0.bundle.js</code> ，打开网页我们会发现3秒之后 <code>0.bundle.js</code> 才会加载。</p>
<h4 id="bundle-loader"><a href="#bundle-loader" class="headerlink" title="bundle-loader"></a>bundle-loader</h4><p>除了用上面的 <code>require.ensure</code>，我们还可以用 <code>bundle-loader</code> 来实现代码分割。实例与 <code>require.ensure</code> 类似，只有 <code>main.js</code> 文件略有不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">document.write(&apos;I will perform right now&apos;)</div><div class="line">setTimeout(function()&#123;</div><div class="line">	var load = require(&apos;bundle-loader!./a.js&apos;)</div><div class="line">	load(function(content) &#123;</div><div class="line">	  document.open();</div><div class="line">	  document.write(content);</div><div class="line">	  document.close();</div><div class="line">	&#125;);</div><div class="line">&#125;, 3000)</div></pre></td></tr></table></figure>
<p>webpack 同样打包生成了两个文件 <code>bundle.js</code> 和 <code>0.bundle.js</code> ，同时也实现了按需加载。</p>
<p>####　通用的代码块</p>
<p>我们先来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// main1.js</div><div class="line">import Vue from &apos;vue&apos;</div><div class="line">var vm = new Vue(&#123;</div><div class="line">	el: &apos;#a&apos;,</div><div class="line">	data: &#123;</div><div class="line">		a: &quot;Hello&quot;</div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// main2.js</div><div class="line">import Vue from &apos;vue&apos;</div><div class="line">var vm = new Vue(&#123;</div><div class="line">	el: &apos;#b&apos;,</div><div class="line">	data: &#123;</div><div class="line">		b: &quot;ReedSun&quot;</div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// index.html</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;div id=&quot;a&quot;&gt;&#123;&#123;a&#125;&#125;&lt;/div&gt;</div><div class="line">		&lt;div id=&quot;b&quot;&gt;&#123;&#123;b&#125;&#125;&lt;/div&gt;</div><div class="line">		&lt;script src=&quot;bundle1.js&quot;&gt;&lt;/script&gt;</div><div class="line">		&lt;script src=&quot;bundle2.js&quot;&gt;&lt;/script&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// webpack.config.js</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		bundle1: &apos;./main1.js&apos;,</div><div class="line">		bundle2: &apos;./main2.js&apos;</div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		filename: &apos;[name].js&apos;</div><div class="line">	&#125;,</div><div class="line">	resolve: &#123;</div><div class="line">		alias: &#123;</div><div class="line">			&apos;vue&apos;: &apos;vue/dist/vue.js&apos;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>webpack.config.js</code>中的 <code>resolve</code> 是别名的意思，通过配置它，我们可以直接使用 <code>require(&#39;vue&#39;)</code>， 而不用使用 <code>require(&#39;vue/dist/vue.js&#39;)</code> 了。</p>
<p>这是一个用Vue渲染页面的简单用例，我们使用 webpack 打包后惊人的发现， webpack在两个脚本中将 <code>Vue</code> 打包了两次！ 这怎么能行！还好，万能的 webpack 提供了 <code>CommonsChunkPlugin</code> 插件，这个插件可以将不同脚本中引用的相同的代码块提取出来，打包成一个单独通用代码块，厉害了我的哥！</p>
<p>使用 <code>CommonsChunkPlugin</code> 插件，我们需要对 <code>index.html</code> 和 <code>webpack.config.js</code> 做如下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// index.html</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;div id=&quot;a&quot;&gt;&#123;&#123;a&#125;&#125;&lt;/div&gt;</div><div class="line">		&lt;div id=&quot;b&quot;&gt;&#123;&#123;b&#125;&#125;&lt;/div&gt;</div><div class="line">		&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;</div><div class="line">		&lt;script src=&quot;bundle1.js&quot;&gt;&lt;/script&gt;</div><div class="line">		&lt;script src=&quot;bundle2.js&quot;&gt;&lt;/script&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;)</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		bundle1: &apos;./main1.js&apos;,</div><div class="line">		bundle2: &apos;./main2.js&apos;</div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		filename: &apos;[name].js&apos;</div><div class="line">	&#125;,</div><div class="line">	resolve: &#123;</div><div class="line">		alias: &#123;</div><div class="line">			&apos;vue&apos;: &apos;vue/dist/vue.js&apos;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new CommonsChunkPlugin(&apos;common&apos;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>嗯~这样一来，通用的依赖只会被 Webpack 打包一次，优化了好多性能。</p>
<h4 id="Vendor-chunk"><a href="#Vendor-chunk" class="headerlink" title="Vendor chunk"></a>Vendor chunk</h4><p>上例中，我们用 <code>CommonsChunkPlugin</code> 将通用的代码块分离出来。当然，我们也可以用它来将第三方库类文件和我们自己写的代码分离。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">\\ index.html</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;div id=&quot;a&quot;&gt;&#123;&#123;a&#125;&#125;&lt;/div&gt;</div><div class="line">		&lt;script src=&quot;vendor.js&quot;&gt;&lt;/script&gt;</div><div class="line">		&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">\\ main.js</div><div class="line">import Vue from &apos;vue&apos;</div><div class="line">var vm = new Vue(&#123;</div><div class="line">	el: &apos;#a&apos;,</div><div class="line">	data: &#123;</div><div class="line">		a: &quot;Hello&quot;</div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">\\ webpack.config.js</div><div class="line">var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;)</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		app: &apos;./main.js&apos;,</div><div class="line">		vendor: [&apos;vue&apos;]</div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		filename: &apos;bundle.js&apos;</div><div class="line">	&#125;,</div><div class="line">	resolve: &#123;</div><div class="line">		alias: &#123;</div><div class="line">			&apos;vue&apos;: &apos;vue/dist/vue.js&apos;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new webpack.optimize.CommonsChunkPlugin(/* chunkName= */&apos;vendor&apos;, /* filename= */&apos;vendor.js&apos;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行 <code>webpack</code> 之后，程序会把代码打包到两个文件 <code>bundls.js</code> 和 <code>vendor.js</code> ，这样就把我们自己的代码和我们引入的第三方库进行了分离。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/webpack/webpack学习笔记 （下）/" data-id="cj3326evu001qwgu1jcdxxn77" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vuex/Vuex的五个核心属性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/vuex/Vuex的五个核心属性/" class="article-date">
  <time datetime="2017-05-24T14:01:51.370Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Vuex的五个核心概念"><a href="#Vuex的五个核心概念" class="headerlink" title="Vuex的五个核心概念"></a>Vuex的五个核心概念</h1><p>本文参考自<a href="http://vuex.vuejs.org/zh-cn/" target="_blank" rel="external">Vue文档</a>，说的非常详细，建议看文档。</p>
<h2 id="Vuex是什么？"><a href="#Vuex是什么？" class="headerlink" title="Vuex是什么？"></a>Vuex是什么？</h2><p>VueX 是一个专门为 Vue.js 应用设计的状态管理架构，统一管理和维护各个vue组件的可变化状态(你可以理解成 vue 组件里的某些 data )。</p>
<p>Vue有五个核心概念，<code>state</code>, <code>getters</code>, <code>mutations</code>, <code>actions</code>, <code>modules</code>。本文将对这个五个核心概念进行梳理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> state =&gt; 基本数据<br> getters =&gt; 从基本数据派生的数据<br> mutations =&gt; 提交更改数据的方法，同步！<br> actions =&gt; 像一个装饰器，包裹mutations，使之可以异步。<br> modules =&gt; 模块化Vuex</p>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>state即Vuex中的基本数据！</p>
<h4 id="单一状态树"><a href="#单一状态树" class="headerlink" title="单一状态树"></a>单一状态树</h4><p>Vuex使用单一状态树，即用一个对象就包含了全部的状态数据。<code>state</code>作为构造器选项，定义了所有我们需要的基本状态参数。</p>
<h4 id="在Vue组件中获得Vuex属性"><a href="#在Vue组件中获得Vuex属性" class="headerlink" title="在Vue组件中获得Vuex属性"></a>在Vue组件中获得Vuex属性</h4><ul>
<li>我们可以通过Vue的<code>Computed</code>获得Vuex的state，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">const store = new Vuex.Store(&#123;</div><div class="line">    state: &#123;</div><div class="line">        count:0</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">const app = new Vue(&#123;</div><div class="line">    //..</div><div class="line">    store,</div><div class="line">    computed: &#123;</div><div class="line">        count: function()&#123;</div><div class="line">            return this.$store.state.count</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    //..</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>每当 <code>store.state.count</code> 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。</p>
<h4 id="mapState辅助函数"><a href="#mapState辅助函数" class="headerlink" title="mapState辅助函数"></a>mapState辅助函数</h4><p>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 在单独构建的版本中辅助函数为 Vuex.mapState</div><div class="line">import &#123; mapState &#125; from &apos;vuex&apos;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  // ...</div><div class="line">  computed: mapState(&#123;</div><div class="line">    // 箭头函数可使代码更简练</div><div class="line">    count: state =&gt; state.count,</div><div class="line"></div><div class="line">    // 传字符串参数 &apos;count&apos; 等同于 `state =&gt; state.count`</div><div class="line">    countAlias: &apos;count&apos;,</div><div class="line"></div><div class="line">    // 为了能够使用 `this` 获取局部状态，必须使用常规函数</div><div class="line">    countPlusLocalState (state) &#123;</div><div class="line">      return state.count + this.localCount</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">computed: mapState([</div><div class="line">  // 映射 this.count 为 store.state.count</div><div class="line">  &apos;count&apos;</div><div class="line">])</div></pre></td></tr></table></figure></p>
<h4 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h4><p>mapState 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。但是自从有了对象展开运算符，我们可以极大地简化写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  localComputed () //本地计算属性</div><div class="line">  //使用对象展开运算符将此对象混入到外部对象中</div><div class="line">  ...mapState(&#123;</div><div class="line">    //..</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>对象运算符<br>  <code>...</code> 展开运算符（spread operator）允许一个表达式在某处展开。展开运算符在多个参数（用于函数调用）或多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方可以使用。</p>
<p>  展开运算符不能用在对象当中，因为目前展开运算符只能在可遍历对象（iterables）可用。iterables的实现是依靠[Symbol.iterator]函数，而目前只有Array,Set,String内置[Symbol.iterator]方法，而Object尚未内置该方法，因此无法使用展开运算符。不过ES7草案当中已经加入了对象展开运算符特性。</p>
<p>  例子：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function test(a,b,c) &#123;</div><div class="line">    console.log(a);</div><div class="line">    console.log(b);</div><div class="line">    console.log(c);</div><div class="line">&#125;</div><div class="line">var args = [0,1,2];</div><div class="line">test(...args);  // 0  1  2</div></pre></td></tr></table></figure>
<ul>
<li>ES7草案中的对象展开运算符<br>  ES6中还不支持对对象的展开运算符，但是ES7中将支持。对象展开运算符符可以让我们更快捷地操作对象，如下例子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let &#123;x,y,...z&#125;=&#123;x:1,y:2,a:3,b:4&#125;;</div><div class="line">x; //1</div><div class="line">y; //2</div><div class="line">z; //&#123;a:3,b:4&#125;</div></pre></td></tr></table></figure>
<h4 id="组件仍然保有局部状态"><a href="#组件仍然保有局部状态" class="headerlink" title="组件仍然保有局部状态"></a>组件仍然保有局部状态</h4><p>使用 Vuex 并不意味着你需要将所有的状态放入 Vuex。虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。</p>
<p>如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。</p>
<h2 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h2><p>即从store的<code>state</code>中派生出的状态。</p>
<p>getters接收state作为其第一个参数，接受其他 getters 作为第二个参数，如不需要，第二个参数可以省略如下例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">const store = new Vuex.Store(&#123;</div><div class="line">    state: &#123;</div><div class="line">        count:0</div><div class="line">    &#125;，</div><div class="line">    getters: &#123;</div><div class="line">        // 单个参数</div><div class="line">        countDouble: function(state)&#123;</div><div class="line">            return state.count * 2</div><div class="line">        &#125;,</div><div class="line">        // 两个参数</div><div class="line">        countDoubleAndDouble: function(state, getters) &#123;</div><div class="line">            return getters.countDouble * 2</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>与state一样，我们也可以通过Vue的<code>Computed</code>获得Vuex的getters。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">const app = new Vue(&#123;</div><div class="line">    //..</div><div class="line">    store,</div><div class="line">    computed: &#123;</div><div class="line">        count: function()&#123;</div><div class="line">            return this.$store.state.count</div><div class="line">        &#125;,</div><div class="line">        countDouble: function()&#123;</div><div class="line">            return this.$store.getters.countDouble</div><div class="line">        &#125;,</div><div class="line">        countDoubleAndDouble: function()&#123;</div><div class="line">            return this.$store.getters.countDoubleAndDouble</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    //..</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h4 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h4><p>mapGetters 辅助函数仅仅是将 store 中的 getters 映射到局部计算属性，与state类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import &#123; mapGetters &#125; from &apos;vuex&apos;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  // ...</div><div class="line">  computed: &#123;</div><div class="line">  // 使用对象展开运算符将 getters 混入 computed 对象中</div><div class="line">    ...mapGetters([</div><div class="line">      &apos;countDouble&apos;,</div><div class="line">      &apos;CountDoubleAndDouble&apos;,</div><div class="line">      //..</div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你想将一个 getter 属性另取一个名字，使用对象形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mapGetters(&#123;</div><div class="line">  // 映射 this.double 为 store.getters.countDouble</div><div class="line">  double: &apos;countDouble&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h2><p>提交mutation是更改Vuex中的store中的状态的唯一方法。</p>
<p>mutation必须是同步的，如果要异步需要使用action。</p>
<p>每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，提交载荷作为第二个参数。（提交荷载在大多数情况下应该是一个对象）,提交荷载也可以省略的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">const store = new Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    count: 1</div><div class="line">  &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    //无提交荷载</div><div class="line">    increment(state) &#123;</div><div class="line">        state.count++</div><div class="line">    &#125;</div><div class="line">    //提交荷载</div><div class="line">    incrementN(state, obj) &#123;</div><div class="line">      state.count += obj.n</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//无提交荷载</div><div class="line">store.commit(&apos;increment&apos;)</div><div class="line">//提交荷载</div><div class="line">store.commit(&apos;incrementN&apos;, &#123;</div><div class="line">    n: 100</div><div class="line">    &#125;)</div></pre></td></tr></table></figure></p>
<h4 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h4><p>我们也可以使用这样包含 type 属性的对象的提交方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">store.commit(&#123;</div><div class="line">  type: &apos;incrementN&apos;,</div><div class="line">  n: 10</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="Mutations-需遵守-Vue-的响应规则"><a href="#Mutations-需遵守-Vue-的响应规则" class="headerlink" title="Mutations 需遵守 Vue 的响应规则"></a>Mutations 需遵守 Vue 的响应规则</h3><ul>
<li>最好提前在你的 store 中初始化好所有所需属性。</li>
<li>当需要在对象上添加新属性时，你应该<ul>
<li>使用 <code>Vue.set(obj, &#39;newProp&#39;, 123)</code>, 或者</li>
<li>以新对象替换老对象。例如，利用对象展开运算符我们可以这样写<code>state.obj = {...state.obj, newProp: 123 }</code></li>
</ul>
</li>
</ul>
<h3 id="mapMutations-辅助函数"><a href="#mapMutations-辅助函数" class="headerlink" title="mapMutations 辅助函数"></a>mapMutations 辅助函数</h3><p>与其他辅助函数类似，你可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import &#123; mapMutations &#125; from &apos;vuex&apos;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  //..</div><div class="line">  methods: &#123;</div><div class="line">    ...mapMutations([</div><div class="line">      &apos;increment&apos; // 映射 this.increment() 为 this.$store.commit(&apos;increment&apos;)</div><div class="line">    ]),</div><div class="line">    ...mapMutations(&#123;</div><div class="line">      add: &apos;increment&apos; // 映射 this.add() 为 this.$store.commit(&apos;increment&apos;)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>Action 类似于 mutation，不同在于：</p>
<ul>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
<li>Action 可以包含任意异步操作。</li>
</ul>
<p>我们用如下例子来结束actions：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">const store = new Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    count: 0</div><div class="line">  &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  actions: &#123;</div><div class="line">    increment (context) &#123;</div><div class="line">      setInterval(function()&#123;</div><div class="line">        context.commit(&apos;increment&apos;)</div><div class="line">      &#125;, 1000)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><strong>注意：Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象</strong>，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。</p>
<h3 id="分发actions"><a href="#分发actions" class="headerlink" title="分发actions"></a>分发actions</h3><p>Action 通过 <code>store.dispatch</code> 方法触发：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.dispatch(&apos;increment&apos;)</div></pre></td></tr></table></figure></p>
<h3 id="其他与mutations类似的地方"><a href="#其他与mutations类似的地方" class="headerlink" title="其他与mutations类似的地方"></a>其他与mutations类似的地方</h3><p>Actions 支持同样的载荷方式和对象方式进行分发：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 以载荷形式分发</div><div class="line">store.dispatch(&apos;incrementN&apos;, &#123;</div><div class="line">  n: 10</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 以对象形式分发</div><div class="line">store.dispatch(&#123;</div><div class="line">  type: &apos;incrementN&apos;,</div><div class="line">  n: 10</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>mapActions辅助函数</p>
<p>你在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 <code>store</code>）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import &#123; mapActions &#125; from &apos;vuex&apos;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  //..</div><div class="line">  methods: &#123;</div><div class="line">    ...mapActions([</div><div class="line">      &apos;incrementN&apos; //映射 this.incrementN() 为 this.$store.dispatch(&apos;incrementN&apos;)</div><div class="line">    ]),</div><div class="line">    ...mapActions(&#123;</div><div class="line">      add: &apos;incrementN&apos; //映射 this.add() 为 this.$store.dispatch(&apos;incrementN&apos;)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。</p>
<p>为了解决以上问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">const moduleA = &#123;</div><div class="line">  state: &#123; ... &#125;,</div><div class="line">  mutations: &#123; ... &#125;,</div><div class="line">  actions: &#123; ... &#125;,</div><div class="line">  getters: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const moduleB = &#123;</div><div class="line">  state: &#123; ... &#125;,</div><div class="line">  mutations: &#123; ... &#125;,</div><div class="line">  actions: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const store = new Vuex.Store(&#123;</div><div class="line">  modules: &#123;</div><div class="line">    a: moduleA,</div><div class="line">    b: moduleB</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">store.state.a // -&gt; moduleA 的状态</div><div class="line">store.state.b // -&gt; moduleB 的状态</div></pre></td></tr></table></figure></p>
<h3 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h3><p>对于模块内部的 <code>mutation</code> 和 <code>getter</code>，接收的第一个参数是模块的局部状态,对于模块内部的 getter，根节点状态会作为第三个参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const moduleA = &#123;</div><div class="line">  state: &#123; count: 0 &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      // state 模块的局部状态</div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  getters: &#123;</div><div class="line">    doubleCount (state) &#123;</div><div class="line">      return state.count * 2</div><div class="line">    &#125;,</div><div class="line">    sumWithRootCount (state, getters, rootState) &#123;</div><div class="line">      return state.count + rootState.count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，对于模块内部的 action，<code>context.state</code> 是局部状态，根节点的状态是 <code>context.rootState</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const moduleA = &#123;</div><div class="line">  // ...</div><div class="line">  actions: &#123;</div><div class="line">    incrementIfOddOnRootSum (context) &#123;</div><div class="line">      if ((context.state.count + context.rootState.count) % 2 === 1) &#123;</div><div class="line">        commit(&apos;increment&apos;)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/vuex/Vuex的五个核心属性/" data-id="cj3326evr001owgu1z5r73i3p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-webpack/webpack学习笔记 （上）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/webpack/webpack学习笔记 （上）/" class="article-date">
  <time datetime="2017-05-24T14:01:51.370Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="webpack学习笔记-（上）"><a href="#webpack学习笔记-（上）" class="headerlink" title="webpack学习笔记 （上）"></a>webpack学习笔记 （上）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这几天晚上在跟着<a href="https://github.com/ruanyf/webpack-demos" target="_blank" rel="external">阮一峰的Webpack教程</a>复习Webpack，发现Webpack确实是一个非常优秀的前端工具，能做的事真是超级多。当然能做的事情越多，他的配置文件可能就越复杂。像我记性这么差的人。还是写个博客记录一下吧！毕竟好记性不如烂笔头！</p>
<h2 id="关于webpack"><a href="#关于webpack" class="headerlink" title="关于webpack"></a>关于webpack</h2><p>webpack的配置文件是 <code>webpack.config.js</code> ， <code>webpack.config.js</code> 通过 <code>module.exports</code> 输出配置文件。</p>
<p>有了 <code>webpack.config.js</code> 之后，我们就可以通过在命令行执行如下命令使用webpack打包我们的代码了。</p>
<ul>
<li><code>$ webpack</code> =&gt; 基本操作，为开发环境打包代码</li>
<li><code>$ webpack -p</code> =&gt; 为生产环境打包代码（压缩代码）</li>
<li><code>$ webpack --watch</code> =&gt; 增量打包代码 （每次修改文件即会自动重新打包文件）</li>
<li><code>$ webpack -d</code> =&gt; 打包同时生成source maps位置文件</li>
<li><code>$ webpack --colors</code> =&gt; 让打包信息使用不同的颜色，易于观察</li>
</ul>
<p>我们可以使用 <code>npm</code> 配置文件 <code>package.json</code> 的 <code>scripts</code> 命令简化我们的操作，示例如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// package.json</div><div class="line">&#123;</div><div class="line">    // ...</div><div class="line">    &quot;script&quot;: &#123;</div><div class="line">        &quot;dev&quot; : &quot;webpack --watch --colors&quot;</div><div class="line">    &#125;,</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="关于webpack-Dev-Server"><a href="#关于webpack-Dev-Server" class="headerlink" title="关于webpack Dev Server"></a>关于webpack Dev Server</h2><p>关于 <code>webpack Dev Server</code> ，<a href="https://github.com/webpack/webpack-dev-server" target="_blank" rel="external">webpack的GitHub</a>是这么介绍它的：</p>
<blockquote>
<p>Serves a webpack app. Updates the browser on changes.</p>
</blockquote>
<p><code>webpack Dev Server</code>是一个小型的服务器，为我们的webpack应用服务。与 <code>webpack</code> 类似，我们在命令行中通过执行如下指令打开服务器、打包代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ webpack-dev-server</div></pre></td></tr></table></figure></p>
<p>我们打开了服务器，就可以在浏览器中通过<code>http://loaclhost:8080</code>访问网页，查看我们打包的代码。</p>
<p>同时， <code>webpack-dev-server</code> 还支持热重载，即我们更新了我们代码，页面将自动刷新并打包我们的代码。</p>
<h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>入口文件是 <code>webpack</code> 运行并打包文件的入口文件。Webpack 会分析入口文件，解析包含依赖关系的各个文件。将这些文件（模块）都打包到 bundle.js 。我们通过 <code>entry</code> 属性来指定它。如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// webpack.config.js</div><div class="line">module.exports = &#123;</div><div class="line">    entry: &apos;./main.js&apos;,</div><div class="line">    output: &#123;</div><div class="line">        filename: &apos;bundles.js&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时入口文件是 <code>main.js</code>， <code>webpack</code> 会将 <code>main.js</code> 打包到 <code>bundles.js</code> 文件中。</p>
<p>入口文件也可以是多个文件，这对一个多页应用来说很有帮助。如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    entry: &#123;</div><div class="line">        bundle1: &apos;./main1.js&apos;,</div><div class="line">        bundle2: &apos;./main2.js&apos;</div><div class="line">    &#125;,</div><div class="line">    output: &apos;[name].js]&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时入口文件有两个，分别是 <code>main1.js</code> 和 <code>main2.js</code> ， <code>webpack</code> 会将这两个文件分别打包到 <code>bundle1.js</code> 和 <code>bundle2.js</code> 中。</p>
<h3 id="加载器（loader）"><a href="#加载器（loader）" class="headerlink" title="加载器（loader）"></a>加载器（loader）</h3><p>加载器是需要用webpack打包的资源文件的预处理器。我在这里将介绍 <code>Bable-loader</code> 、 <code>CSS-loader</code> 和 <code>Image-loader</code> 这三个加载器。</p>
<p>加载器需要在配置文件中的 <code>module.loaders</code>中定义，如下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">module.explorts = &#123;</div><div class="line">    // ..</div><div class="line">    module: &#123;</div><div class="line">        loaders: &#123;</div><div class="line">            test: /\.js[x]?$/,  // 正则匹配需要用加载器预处理的文件</div><div class="line">            exclude: /node_modules/,  // 正则匹配排除的文件或文件夹, 忽略则匹配所有涉及的文件</div><div class="line">            include: /src/,  // 正则匹配包含的文件或文件，忽略则匹配所有涉及的文件</div><div class="line">            loader: &apos;babel-loader&apos;  // 加载器</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="bable-loader"><a href="#bable-loader" class="headerlink" title="bable-loader"></a>bable-loader</h4><p><code>Bable-loader</code> 可以将 JSX/ES6 文件转化为 ES5 规范下的 JS 文件。如下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;</div><div class="line">    loaders:[</div><div class="line">      &#123;</div><div class="line">        test: /\.js[x]?$/,</div><div class="line">        exclude: /node_modules/,</div><div class="line">        loader: &apos;babel-loader?presets[]=es2015&apos;</div><div class="line">      &#125;,</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里 <code>babel-loader</code> 需要用到 <code>babel-preset-es2015</code> 插件，将 <code>ES2015</code> 语法转化为 <code>ES5</code> 语法，如上示例是一种写法，还有另一种写法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">module: &#123;</div><div class="line">  loaders: [</div><div class="line">    &#123;</div><div class="line">      test: /\.jsx?$/,</div><div class="line">      exclude: /node_modules/,</div><div class="line">      loader: &apos;babel&apos;,</div><div class="line">      query: &#123;</div><div class="line">        presets: [&apos;es2015&apos;]</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h4><p>如果我们在被 Webpack 处理的文件中引入了 CSS 文件，我们就需要使用 <code>CSS-loader</code> 来处理这些 CSS 文件，如下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ..</div><div class="line">  module: &#123;</div><div class="line">    loaders:[</div><div class="line">      &#123; </div><div class="line">          test: /\.css$/, </div><div class="line">          loader: &apos;style-loader!css-loader&apos; &#125;,</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注意，我们这里使用两个加载器来转换 CSS 文件， 一个是 <code>css-loader</code> 来编译CSS文件， 另一个是 <code>style-loader</code> 将 CSS 代码引入 HTML 文件中。</p>
<p>两个不同的加载器需要用 <code>!</code> 来连接。</p>
<h4 id="image-loader"><a href="#image-loader" class="headerlink" title="image-loader"></a>image-loader</h4><p>Webpack 也可以打包图片到JS中，如下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;</div><div class="line">    loaders:[</div><div class="line">      &#123; </div><div class="line">          test: /\.(png|jpg)$/, </div><div class="line">          loader: &apos;url-loader?limit=8192&apos; &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>看这里 <code>url-loader?limit=8192</code> ，我们之前在 <code>bable-loader</code> 里见过， 这次的查询关键词是 <code>limit</code> ，意义是最大限制，即 如果小于 8192B 的图片文件将会被转换，小于8192B 的图片文件将不会被转换。</p>
<h3 id="插件（plugin）"><a href="#插件（plugin）" class="headerlink" title="插件（plugin）"></a>插件（plugin）</h3><p>Webpack有一套插件系统来扩展他的功能，我们之前说了加载器是在配置文件中的 <code>modules.loaders</code> 中声明，而插件就是在 <code>plugins</code> 中声明。</p>
<p>我们在这里介绍三个插件 <code>uglifyJsPlugin</code> 、 <code>html-webpack-plugin</code> 和 <code>open-browser-webpack-plugin</code> 。</p>
<p>如它的名字， <code>uglifyJsPlugin</code> 作用是压缩JS代码，是 Webpack 自带的插件。</p>
<p><code>html-webpack-plugin</code> 和 <code>open-browser-webpack-plugin</code> 都是 Webpack 的第三方插件。 <code>html-webpack-plugin</code> 的作用是自动生成一个 HTML 文件。 <code>open-browser-webpack-plugin</code> 的作用是可以在 Webpack 加载时自动打开一个浏览器页面，这个可就厉害了，配合 <code>webpack-dev-server</code> 我们可以在 Webpack 执行后，不用动手就看到效果。</p>
<p>如下示例展示了这三个插件的声明方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var webpack = require(&apos;webpack&apos;);</div><div class="line">var uglifyJsPlugin = webpack.optimize.UglifyJsPlugin;</div><div class="line">module.exports = &#123;</div><div class="line">  // ..</div><div class="line">  plugins: [</div><div class="line">    new uglifyJsPlugin(&#123;</div><div class="line">      compress: &#123;</div><div class="line">        warnings: false</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">    new HtmlwebpackPlugin(&#123;</div><div class="line">      title: &apos;Webpack-demos&apos;,</div><div class="line">      filename: &apos;index.html&apos;</div><div class="line">    &#125;),</div><div class="line">    new OpenBrowserPlugin(&#123;</div><div class="line">      url: &apos;http://localhost:8080&apos;</div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样，我们不需要写 HTML 文件，运行 <code>webpack-dev-server</code> ， Webpack就自动为我们打包代码、压缩代码、创建 HTML 文件、打开浏览器。帅！</p>
<h3 id="环境标识"><a href="#环境标识" class="headerlink" title="环境标识"></a>环境标识</h3><p>Webpack 允许我们使用环境标识来区分开发环境和生产环境，从而让我们在开发环境中执行一些额外的代码。</p>
<p>比如，如果我们只想在开发环境中执行 <code>document.write(new Date())</code> 我们可以这样写我们的入口文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">document.write(&apos;&lt;h1&gt;Hello World&lt;/h1&gt;&apos;);</div><div class="line"></div><div class="line">if (devEnvironment) &#123;</div><div class="line">  document.write(new Date());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在配置文件中使用 <code>DefinePlugin</code> 插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var webpack = require(&apos;webpack&apos;);</div><div class="line"></div><div class="line">var devFlagPlugin = new webpack.DefinePlugin(&#123;</div><div class="line">  devEnvironment: JSON.stringify(JSON.parse(process.env.DEBUG || &apos;false&apos;))</div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  entry: &apos;./main.js&apos;,</div><div class="line">  output: &#123;</div><div class="line">    filename: &apos;bundle.js&apos;</div><div class="line">  &#125;,</div><div class="line">  plugins: [devFlagPlugin]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>最后，我们只需要在执行 Webpack 命令时传入环境标识，Webpack就会为我们将环境标识设为我们需要的值，从而确定执不执行一些代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ env DEBUG=true webpack  // 此时为开发环境，执行额外代码</div><div class="line">$ webpack  // 此时为生产环境，不执行额外代码</div></pre></td></tr></table></figure>
<p>(未完待续)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/webpack/webpack学习笔记 （上）/" data-id="cj3326evt001pwgu1eows04a9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python/python中的元类Metaclass/python中的元类Metaclass" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/python/python中的元类Metaclass/python中的元类Metaclass/" class="article-date">
  <time datetime="2017-05-24T14:01:51.330Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="python中的元类Metaclass"><a href="#python中的元类Metaclass" class="headerlink" title="python中的元类Metaclass"></a>python中的元类Metaclass</h1><h2 id="理解元类之前需要学习的知识"><a href="#理解元类之前需要学习的知识" class="headerlink" title="理解元类之前需要学习的知识"></a>理解元类之前需要学习的知识</h2><p> 如果说让我们创建一个类，最先想到的肯定是用<code>class</code>创建，当我们使用<code>class</code>创建类的时候，python解释器自动创建这个对象，但是python同样也提供了手动处理的方法来创建类，这就是用python的自建函数<code>type()</code>。</p>
<p> 我们所熟知的<code>type()</code>函数的作用是返回一个参数的类型，但是实际上，它也有一种完全不同的能力，即接受一个类的一些描述作为参数，然后返回一个类。</p>
<p> <code>type()</code>函数的语法是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)</div></pre></td></tr></table></figure></p>
<p>举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class ReedSun(ShuaiGe):</div><div class="line">    shuai = True</div><div class="line">    def test(x):</div><div class="line">        return x+2</div><div class="line"># 就等价于</div><div class="line">type(&quot;ReedSun&quot;, (ShuaiGe,), &#123;&quot;shuai&quot;:True, &quot;test&quot;:lambda x: x+2&#125;)</div><div class="line"># （属性和方法本质上都是方法）</div></pre></td></tr></table></figure></p>
<p>在python中，类也是对象，当我们使用class关键词创建一个类的时候，Python解释器仅仅是扫描一下class定义的语法，然后调用<code>type()</code>函数创建出class。</p>
<h2 id="元类是什么"><a href="#元类是什么" class="headerlink" title="元类是什么"></a>元类是什么</h2><p>元类是什么？元类实际上就是用来创建类的东西。为了帮助我们理解，我们可以这样想，我们创建类就是为了创建类的实例，同样的，我们创建元类就是为了创建类。元类就是类<em>（实例）</em>的类，就像下面这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Metaclass() = class</div><div class="line">class() = object  # object==&gt;实例</div></pre></td></tr></table></figure></p>
<p>理解了什么是元类，我们再来看一看type()函数。</p>
<p>其实type就是一个元类，type就是我们用来创建所有的类的元类。（如果我们要创建自己定义的元类的话，也要从type中继承）</p>
<h2 id="元类的工作原理"><a href="#元类的工作原理" class="headerlink" title="元类的工作原理"></a>元类的工作原理</h2><p>我们来看一下下面这个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class ReedSunMetaclass(type):</div><div class="line">    pass</div><div class="line">    </div><div class="line">class Foo(object， metaclass = ReedSunMetaclass): </div><div class="line">    pass</div><div class="line">    </div><div class="line">class Bar(Foo):</div><div class="line">    pass</div></pre></td></tr></table></figure></p>
<ol>
<li><p>首先，我们创建了一个元类<code>ReedSunMetaclass</code><em>（注意！按照默认习惯，元类的类名总是以<code>Metaclass</code>结尾，以便清楚地表示这是一个元类）</em>。</p>
</li>
<li><p>然后，我们又用元类<code>ReedSunMetaclass</code>创建了一个<code>Foo</code>类，<em>（同时，<code>Foo</code>类的属性<code>__metaclass__</code>就变成了<code>ReedSunMetaclass</code>)</em>。</p>
</li>
<li><p>最后，我们创建了一个子类<code>Bar</code>继承自<code>Foo</code>。</p>
</li>
</ol>
<p>我们来试着理解一下在python内部是怎么执行这几个步骤的：</p>
<ul>
<li><p>对于父类<code>Foo</code>，Python会在类的定义中寻找<code>__metaclass__</code>属性，如果找到了，Python就会用它来创建类<code>Foo</code>，如果没有找到，就会用内建的type来创建这个类。很显然，它找到了。</p>
</li>
<li><p>对于子类<code>Bar</code>, python会先在子类中寻找<code>__metaclass__</code>属性，如果找到了，Python就会用它来创建类<code>Bar</code>，如果没有找到，就再从父类中寻找，直到type。显然，它在父类中找到了。</p>
</li>
</ul>
<p><strong>我们可以看到使用元类的一个好处了，即他可以让子类隐式的继承一些东西。</strong></p>
<h2 id="自定义元类"><a href="#自定义元类" class="headerlink" title="自定义元类"></a>自定义元类</h2><p>元类的主要目的就是为了当创建类时能够自动地改变类。创建类我们需要定义<code>__new__()</code>函数，<code>__new__</code> 是在<code>__init__</code>之前被调用的特殊方法，是用来创建对象并返回之的方法。我们举个例子来说明定义自定义元类的方法。</p>
<p><code>__new__()</code>方法接收到的参数依次是：</p>
<ol>
<li>当前准备创建的类的对象；</li>
<li>类的名字；</li>
<li>类继承的父类集合；</li>
<li>类的方法集合。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class ReedSunMetaclass(type):</div><div class="line">    def __new__(cls, name, bases, attrs):</div><div class="line">        # 添加一个属性</div><div class="line">        attrs[&apos;哈哈哈&apos;] = True</div><div class="line">        return type.__new__(cls, name, bases, attrs)</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="我们用一个实际例子来说明元类的用法"><a href="#我们用一个实际例子来说明元类的用法" class="headerlink" title="我们用一个实际例子来说明元类的用法"></a>我们用一个实际例子来说明元类的用法</h2><p><code>ORM</code>就是一个典型的使用元类的例子。<code>ORM</code>全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。下面我就用这个<code>ORM</code>的例子来说明一下元类的用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line">#ORM:object relational mapping 对象-关系映射</div><div class="line">#把关系数据库的一行映射为一个对象，也就是一个类对应一个表</div><div class="line">#ORM框架所有的类只能动态定义</div><div class="line"></div><div class="line"></div><div class="line"># 定义Field(定义域：元类遇到Field的方法或属性时即进行修改）</div><div class="line">class Field(object):</div><div class="line"></div><div class="line">    def __init__(self, name, column_type):  # column==&gt;列类型</div><div class="line">        self.name = name</div><div class="line">        self.column_type = column_type</div><div class="line"></div><div class="line">    # 当用print打印输出的时候，python会调用他的str方法</div><div class="line">    # 在这里是输出&lt;类的名字，实例的name参数(定义实例时输入)&gt;</div><div class="line">    # 在ModelMetaclass中会用到</div><div class="line">    def __str__(self):</div><div class="line">        return &quot;&lt;%s:%s&gt;&quot; % (self.__class__.__name__, self. name)  # __class__获取对象的类，__name__取得类名</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># 进一步定义各种类型的Field</div><div class="line">class StringField(Field):</div><div class="line"></div><div class="line">    def __init__(self, name):</div><div class="line">        # super(type[, object-or-type])  返回type的父类对象</div><div class="line">        # super().__init()的作用是调用父类的init函数</div><div class="line">        # varchar(100)和bigint都是sql中的一些数据类型</div><div class="line">        super(StringField, self).__init__(name, &quot;varchar(100)&quot;)  </div><div class="line"></div><div class="line">class IntegerField(Field):</div><div class="line"></div><div class="line">    def __init__(self, name):</div><div class="line">        super(IntegerField, self).__init__(name, &quot;bigint&quot;)</div><div class="line"></div><div class="line"></div><div class="line"># 编写ModelMetaclass</div><div class="line">class ModelMetaclass(type):</div><div class="line">    </div><div class="line">    # __new__方法接受的参数依次是：</div><div class="line">    # 1.当前准备创建的类的对象（cls）</div><div class="line">    # 2.类的名字（name）</div><div class="line">    # 3.类继承的父类集合(bases)</div><div class="line">    # 4.类的方法集合(attrs)</div><div class="line">    def __new__(cls, name, bases, attrs):</div><div class="line">        # 如果说新创建的类的名字是Model，那直接返回不做修改</div><div class="line">        if name == &quot;Model&quot;:</div><div class="line">            return type.__new__(cls, name, bases, attrs)</div><div class="line">        print(&quot;Found model:%s&quot; % name)</div><div class="line">        mappings = dict()</div><div class="line">        for k, v in attrs.items():</div><div class="line">            if isinstance(v, Field):</div><div class="line">                print(&quot;Found mappings:%s ==&gt; %s&quot; % (k, v))  # 找到映射， 这里用到上面的__str__</div><div class="line">                mappings[k] = v</div><div class="line">            # 结合之前，即把之前在方法集合中的零散的映射删除，</div><div class="line">            # 把它们从方法集合中挑出，组成一个大方法__mappings__</div><div class="line">            # 把__mappings__添加到方法集合attrs中</div><div class="line">        for k in mappings.keys():</div><div class="line">                attrs.pop(k)</div><div class="line">        attrs[&quot;__mappings__&quot;] = mappings</div><div class="line">        attrs[&quot;__table__&quot;] = name # 添加表名，假设表名与类名一致</div><div class="line">        return type.__new__(cls, name, bases, attrs)</div><div class="line"></div><div class="line"></div><div class="line"># 编写Model基类继承自dict中，这样可以使用一些dict的方法</div><div class="line">class Model(dict, metaclass=ModelMetaclass):</div><div class="line"></div><div class="line">    def __init__(self,  **kw):</div><div class="line">        # 调用父类，即dict的初始化方法</div><div class="line">        super(Model, self).__init__(**kw)</div><div class="line"></div><div class="line">    # 让获取key的值不仅仅可以d[k]，也可以d.k</div><div class="line">    def __getattr__(self, key):</div><div class="line">        try:</div><div class="line">            return self[key]</div><div class="line">        except KeyError:</div><div class="line">            raise AttributeError(r&quot;&apos;Model&apos; object has no attribute &apos;%s&apos;&quot; % key)</div><div class="line"></div><div class="line">    # 允许动态设置key的值，不仅仅可以d[k]，也可以d.k</div><div class="line">    def __setattr__(self, key, value):</div><div class="line">        self[key] = value</div><div class="line"></div><div class="line">    def save(self):</div><div class="line">        fields = []</div><div class="line">        params = []</div><div class="line">        args = []</div><div class="line">        # 在所有映射中迭代</div><div class="line">        for k, v in self.__mappings__.items():</div><div class="line">            fields.append(v.name)</div><div class="line">            params.append(&quot;?&quot;)</div><div class="line">            args.append(getattr(self, k, None))</div><div class="line">        sql = &quot;insert into %s (%s) values (%s)&quot; % (self.__table__, &quot;,&quot;.join(fields), &quot;,&quot;.join(params))</div><div class="line">        print(&quot;SQL: %s&quot; % sql)</div><div class="line">        print(&quot;ARGS: %s&quot; % str(args))</div><div class="line"></div><div class="line"></div><div class="line"># 这样一个简单的ORM就写完了</div><div class="line"></div><div class="line"></div><div class="line"># 下面实际操作一下，先定义个User类来对应数据库的表User</div><div class="line">class User(Model):</div><div class="line">    # 定义类的属性到列的映射</div><div class="line">    id = IntegerField(&quot;id&quot;)</div><div class="line">    name = StringField(&quot;username&quot;)</div><div class="line">    email = StringField(&quot;email&quot;)</div><div class="line">    password = StringField(&quot;password&quot;)</div><div class="line"></div><div class="line"></div><div class="line"># 创建一个实例</div><div class="line">u = User(id=12345, name=&quot;ReedSun&quot;, email=&quot;sunhongzhao@foxmail.com&quot;, password=&quot;nicaicai&quot;)</div><div class="line">u.save()</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319106919344c4ef8b1e04c48778bb45796e0335839000" target="_blank" rel="external">使用元类-廖雪峰的官方网站</a></li>
<li><a href="http://blog.jobbole.com/21351/" target="_blank" rel="external">深刻理解python中的元类</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/python/python中的元类Metaclass/python中的元类Metaclass/" data-id="cj3326ewb001rwgu16bcz9jyb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python/获取对象信息" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/python/获取对象信息/" class="article-date">
  <time datetime="2017-05-24T14:01:51.300Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h1><p><em>学习日期：2016年9月27日</em><br><em>学习课程：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431866385235335917b66049448ab14a499afd5b24db000" target="_blank" rel="external">获取对象信息 - 廖雪峰的官方网站</a></em><br>在本节中，我学习了可以通过<code>type()</code>或者<code>isinstance()</code>可以获得和判断对象的类型信息，他们两者的不同,在于<code>type()</code><strong>不会认为</strong>子类是一种父类类型,<code>isinstance()</code><strong>会认为</strong>子类是一种父类类型。<br>还学习了使用<code>dir()</code>可以获得一个对象的所有属性和方法。使用<code>getattr()</code>、<code>setattr()</code>、<code>hasattr()</code>、<code>delsattr()</code>，我们可以操作一个对象的属性和方法</p>
<h2 id="使用type"><a href="#使用type" class="headerlink" title="使用type()"></a>使用<code>type()</code></h2><ul>
<li><code>type(object）</code>函数接收一个object（对象），并且返回这个object对应的class类型。<ul>
<li>object可以是基本数据类型，比如<code>int</code>、<code>str</code>、……</li>
<li>object也可以是一个函数或者一个类（class）,比如<code>abs</code>、<code>Animal</code>……</li>
</ul>
</li>
<li>因为type对象返回对应的class类型，如果要判断一个对象的类型是不是某一个特定的类型的话就比较麻烦。<ul>
<li>对于基本数据类型还好说，可以直接写<code>int</code>、<code>str</code>等来判断，例如<code>type(123)==int</code>。</li>
<li>但是对于其他数据类型（函数、lambda、generator、……）来说，就不能用上面的方法了。但是也有对应的解决之策，那就是使用<code>type</code>模块中定义的常量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import types</div><div class="line">&gt;&gt;&gt; def fn():</div><div class="line">...     pass</div><div class="line">...</div><div class="line">&gt;&gt;&gt; type(fn)==types.FunctionType</div><div class="line">True</div><div class="line">&gt;&gt;&gt; type(abs)==types.BuiltinFunctionType</div><div class="line">True</div><div class="line">&gt;&gt;&gt; type(lambda x: x)==types.LambdaType</div><div class="line">True</div><div class="line">&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorType</div><div class="line">True</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>##使用<code>isinstance()</code></p>
<ul>
<li><p>对于判断一个对象是不是某一个类或者类型，我们有一个类似的函数<code>isinstance()</code>。<code>type()</code>与<code>isinstance()</code>之间不存在孰优孰劣，只有哪个更适合某个特定的需求而已。</p>
</li>
<li><p>他与<code>type()</code>有一个明显的区别，即<code>type()</code>不会认为子类是一种父类类型,而<code>isinstance()</code>会认为子类是一种父类类型。</p>
</li>
<li><p><code>isinstance()</code>的语法是：<code>isinstance(object,class)</code>。</p>
<ul>
<li><code>object</code>是要判断类型的数据对象，<code>class</code>是要判断的类型或者类。</li>
<li><code>class</code>也可以是一个元组（里面包含若干个<code>class</code>或<code>type</code>），这样表达的意思是判断一个对象是否是某些类型中的一种。</li>
</ul>
</li>
<li><p>如果<code>class</code>是<code>object</code>的父类，也会输出<code>True</code>，但是如果<code>class</code>是<code>object</code>的子类，就会输出<code>False</code>。<strong>换句话说，isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。</strong><br>##使用<code>dir()</code></p>
</li>
<li>通过<code>dir()</code>函数我们可以获得一个对象的所有属性和方法，它将返回一个包含对象的全部的属性和方法的字符串的list。</li>
<li>其返回的list中从形式上包含两种大类，一个是<code>__xxx__</code>，另一个是<code>xxx</code>。<ul>
<li>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。</li>
<li><code>xxx</code>则是普通属性或方法，比如<code>lower()</code>返回小写的字符串。</li>
</ul>
</li>
<li>通过<code>getattr()</code>、<code>setattr()</code>、<code>hasattr()</code>、<code>delasttr()</code>，我们可以直接操作一个对象的的属性和方法。<ul>
<li><code>getattr()</code>的作用是访问对象的属性或方法，其语法是<code>getattr(obj, name[, default])</code>，将返回属性或方法的值，如果方法或值不存在，就返回<code>default</code>的值。</li>
<li><code>setattr()</code>的作用是设置一个属性或方法。如果属性不存在，会创建一个新属性，其语法是<code>setattr(obj,name,value)</code>，没有返回值。如果要设置方法，可以使用lambda匿名函数。</li>
<li><code>hasattr()</code>的作用是检查是否存在一个属性或方法，其语法为<code>hasattr(obj,name)</code>。如果存在这个属性或方法返回<code>True</code>，否则返回<code>False</code>。</li>
<li><code>delasttr()</code>的作用是删除一个属性，其语法为<code>delattr(obj, name)</code>。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/python/获取对象信息/" data-id="cj3326evq001nwgu1z4so38i3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python/学习笔记_面向对象高级编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/python/学习笔记_面向对象高级编程/" class="article-date">
  <time datetime="2017-05-24T14:01:51.290Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习笔记-面向对象高级编程"><a href="#学习笔记-面向对象高级编程" class="headerlink" title="学习笔记_面向对象高级编程"></a>学习笔记_面向对象高级编程</h1><p><em>学习日期：2016年9月28日</em><br><em>学习课程：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143186738532805c392f2cc09446caf3236c34e3f980f000" target="_blank" rel="external">面向对象高级编程 - 廖雪峰的官方网站</a></em></p>
<p>在面向对象高级编程这个单元中，我们学习了以下几个方面。</p>
<ul>
<li><p><code>__slots__</code>:限制class中的属性，让我们不能随便在运行中添加属性。</p>
</li>
<li><p><code>@property</code> 这个装饰器可以帮助我们包装属性，让我们只能查看访问属性和有限制的修改类中的属性，还可以帮助我们把类中的属性变为只读。</p>
</li>
<li><p>多重继承 我们可以在主线继承之外的父继承名后加上<code>Mixln</code>，这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</p>
</li>
<li><p>还介绍了五种定制类。</p>
<ul>
<li><code>__str__</code>和<code>__repr__</code>分别是返回用户可以看到的字符串（适用于<code>print()</code>输出），和开发者看到的字符串（适用于直接敲变量返回的字符串）。</li>
<li><code>__iter__</code>可以把类变成一个可迭代对象，从而适用于for…in..循环。</li>
<li><code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code>:在Python中，如果我们想实现创建类似于序列和映射(索引)的类，可以通过重写魔法方法<code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code>方法去模拟。</li>
<li><code>__getattr__</code> 动态返回属性或函数，返回的默认值是<code>None</code>。</li>
<li><code>__call__</code>，定义一个<code>__call__</code>()方法，就可以直接对实例进行调用<ul>
<li><code>Callable(x)</code>函数可以返回一个x可不可以被调用的布尔值。</li>
</ul>
</li>
</ul>
</li>
<li><p>还介绍了枚举类和元类。</p>
<ul>
<li>枚举类用<code>Enum</code>实现。</li>
<li>元类用<code>mataclass</code>实现，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/python/学习笔记_面向对象高级编程/" data-id="cj3326evn001mwgu1irqet60n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python/学习笔记_面向对象编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/python/学习笔记_面向对象编程/" class="article-date">
  <time datetime="2017-05-24T14:01:51.270Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习笔记-面向对象编程"><a href="#学习笔记-面向对象编程" class="headerlink" title="学习笔记_面向对象编程"></a>学习笔记_面向对象编程</h1><p><em>学习日期：2016年9月26日 - 2016年9月27日</em><br><em>学习课程：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318645694388f1f10473d7f416e9291616be8367ab5000" target="_blank" rel="external">面向对象编程 - 廖雪峰的官方网站</a></em></p>
<p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p>
<ul>
<li><p><strong>面向过程的程序设计</strong>把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p>
</li>
<li><p><strong>而面向对象的程序设计</strong>把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>
</li>
</ul>
<p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。</p>
<p>面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。</p>
<p><strong>数据封装、继承和多态是面向对象的三大特点</strong></p>
<ul>
<li><p>数据封装</p>
<ul>
<li><p>既然实例本身就拥有数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在实例的类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和类本身是关联起来的，我们称之为<strong>类的方法</strong>。</p>
</li>
<li><p>这样一来，我们从外部看类，就只需要知道，创建实例需要给出数据，而如何访问调用数据，都是在类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不需要知道内部实现的细节。</p>
</li>
<li>封装的另一个好处是可以很容易的给类增加新的方法。</li>
</ul>
</li>
<li><p>继承</p>
<ul>
<li><p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p>
</li>
<li><p>继承最大的好处是子类获得了父类的全部功能（方法）。</p>
</li>
<li><p>继承的另一个好处：多态。</p>
</li>
</ul>
</li>
<li><p>多态</p>
<ul>
<li>多态是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是：允许将子类类型的指针赋值给父类类型的指针。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/python/学习笔记_面向对象编程/" data-id="cj3326evi001lwgu1woubcrut" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python/学习笔记_错误处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/python/学习笔记_错误处理/" class="article-date">
  <time datetime="2017-05-24T14:01:51.260Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习笔记-错误处理"><a href="#学习笔记-错误处理" class="headerlink" title="学习笔记_错误处理"></a>学习笔记_错误处理</h1><p><em>学习日期：2016年9月28日</em><br><em>学习课程：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143191375461417a222c54b7e4d65b258f491c093a515000" target="_blank" rel="external">错误处理 - 廖雪峰的官方网站</a></em></p>
<p>##try</p>
<ul>
<li><p>try…except…finally…的处理机制。</p>
</li>
<li><p>用<code>try</code>来运行一段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即<code>except</code>语句块，执行完<code>except</code>后，如果有<code>finally</code>语句块，则执行<code>finally</code>语句块，至此，执行完毕。</p>
</li>
<li><p>Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。</p>
</li>
<li><p>使用try…except捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数main()调用foo()，foo()调用bar()，结果bar()出错了，这时，只要main()捕获到了，就可以处理。</p>
</li>
</ul>
<p>##调用堆栈</p>
<ul>
<li><p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。</p>
</li>
<li><p>如果出现错误的话，我们从上往下可以看到整个错误的调用函数链，然后找到错误的源头。</p>
</li>
</ul>
<p>##纪录错误</p>
<ul>
<li>Python内置的logging模块可以非常容易地记录错误信息，同时让程序继续执行下去。</li>
</ul>
<h2 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h2><ul>
<li>我们可以通过<code>raise</code>语句抛出错误。</li>
<li>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如<code>ValueError</code>，<code>TypeError</code>），尽量使用Python内置的错误类型。</li>
<li>raise语句如果不带参数，就会把当前错误原样抛出。</li>
<li>在except中raise一个Error，还可以把一种类型的错误转化成另一种类型。（绝对不应该转化完全不相干的错误类型）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/python/学习笔记_错误处理/" data-id="cj3326evg001kwgu14953qnaz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python/学习笔记_错误、调试和测试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/python/学习笔记_错误、调试和测试/" class="article-date">
  <time datetime="2017-05-24T14:01:51.250Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="错误、调试和测试-单元测试"><a href="#错误、调试和测试-单元测试" class="headerlink" title="错误、调试和测试_单元测试"></a>错误、调试和测试_单元测试</h1><p><em>学习日期：2016年9月28日</em><br><em>学习课程：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431913726557e5e43e1ee8d54ee486bddc3f607afb75000" target="_blank" rel="external">错误、调试和测试 - 廖雪峰的官方网站</a></em></p>
<p>##错误</p>
<ul>
<li><p>在程序运行过程中，总会遇到各种各样的错误。有可能是程序编写的错误，有可能是用户输入的错误，还有可能是完全无法在程序运行过程中预测的错误（异常），比如磁盘满了，网络断了。</p>
</li>
<li><p>Python内置的<code>try...except...finally</code>用来处理错误十分方便。出错时，会分析错误信息并定位错误发生的代码位置才是最关键的。程序也可以主动抛出错误（通过<code>raise</code>语句，让调用者来处理相应的错误。但是，应该在文档中写清楚可能会抛出哪些错误，以及错误产生的原因。</p>
</li>
</ul>
<p>##调试</p>
<ul>
<li>跟踪程序的执行，查看变量的值是否正确，这个过程称为调试。</li>
<li>调试有这么几种方法。<ul>
<li>用<code>print()</code>。（很麻烦）</li>
<li>用<code>assert</code>。（启动Python解释器时可以用-O参数来关闭assert）</li>
<li><code>logging</code>（比较好用）</li>
<li>用一个好的IDE，超赞。</li>
</ul>
</li>
</ul>
<p>##测试</p>
<ul>
<li>测试分为单元测试和文档测试。</li>
<li>编写测试也很重要。有了良好的测试，就可以在程序修改后反复运行，确保程序输出符合我们编写的测试。</li>
</ul>
<p>###单元测试</p>
<ul>
<li>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。（<code>unittest</code>模块）</li>
<li>单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。</li>
<li>单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。</li>
<li>单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。</li>
<li>单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。</li>
</ul>
<p>###文档测试</p>
<ul>
<li>Python内置的“文档测试”（<code>doctest</code>）模块可以直接提取注释中的代码并执行测试。</li>
<li><code>doctest</code>非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含<code>doctest</code>的注释提取出来。用户看文档的时候，同时也看到了<code>doctest</code>。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/python/学习笔记_错误、调试和测试/" data-id="cj3326eve001jwgu170mrvorb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python/学习笔记_进程 vs. 线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/python/学习笔记_进程 vs. 线程/" class="article-date">
  <time datetime="2017-05-24T14:01:51.240Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习笔记-进程-vs-线程"><a href="#学习笔记-进程-vs-线程" class="headerlink" title="学习笔记_进程 vs. 线程"></a>学习笔记_进程 vs. 线程</h1><p><em>学习日期：2016年10月1日</em><br><em>学习课程：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319292979766bd3285c9d6b4942a8ea9b4e9cfb48d8000" target="_blank" rel="external">进程 vs. 线程 - 廖雪峰的官方网站</a></em></p>
<ul>
<li><p>首先，要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。</p>
</li>
<li><p>多进程的优缺点</p>
<ul>
<li><p>多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）</p>
</li>
<li><p>多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用<code>fork</code>调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。</p>
</li>
</ul>
</li>
<li><p>多线程的优缺点</p>
<ul>
<li><p>多线程模式通常比多进程快一点，但是也快不到哪去。</p>
</li>
<li><p>但是多线程有一个致命缺点，任何一个线程挂掉都又可能导致整个系统崩溃。</p>
</li>
</ul>
</li>
</ul>
<h2 id="多任务不要太多！"><a href="#多任务不要太多！" class="headerlink" title="多任务不要太多！"></a>多任务不要太多！</h2><ul>
<li><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去。</p>
</li>
<li><p>多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。</p>
</li>
</ul>
<h2 id="计算密集型-vs-IO密集型"><a href="#计算密集型-vs-IO密集型" class="headerlink" title="计算密集型 vs. IO密集型"></a>计算密集型 vs. IO密集型</h2><ul>
<li><p>计算密集型任务的特点是要进行大量的计算。</p>
<ul>
<li>比如计算圆周率、对视频进行高清解码等等。</li>
<li>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</li>
</ul>
</li>
<li><p>IO密集型的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。</p>
<ul>
<li>比如Web应用。</li>
<li>对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</li>
</ul>
<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2></li>
<li><p>考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。</p>
</li>
<li><p>现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/python/学习笔记_进程 vs. 线程/" data-id="cj3326evd001iwgu1xsxbztgt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/24/webpack/webpack学习笔记 （下）/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/05/24/vuex/Vuex的五个核心属性/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/05/24/webpack/webpack学习笔记 （上）/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/05/24/python/python中的元类Metaclass/python中的元类Metaclass/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/05/24/python/获取对象信息/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>