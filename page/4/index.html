<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-python/学习笔记_struct" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/python/学习笔记_struct/" class="article-date">
  <time datetime="2017-05-24T14:01:50.890Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习笔记-struct"><a href="#学习笔记-struct" class="headerlink" title="学习笔记_struct"></a>学习笔记_struct</h1><p><em>学习日期：2016年10月8日</em><br><em>学习课程：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431955007656a66f831e208e4c189b8a9e9f3f25ba53000" target="_blank" rel="external">struct - 廖雪峰的官方网站</a></em></p>
<ul>
<li><p>Python提供了一个<code>struct</code>模块来解决bytes和其他二进制数据类型的转换。</p>
</li>
<li><p><code>struct</code>的<code>pack</code>函数把任意数据类型变成<code>bytes</code>。</p>
<ul>
<li><code>pack(fmt, v1, v2, ...)</code>  按照给定的格式(fmt)，把数据封装成字符串(实际上是类似于c结构体的字节流)</li>
</ul>
</li>
<li><p><code>unpack</code>把bytes变成相应的数据类型。</p>
<ul>
<li><code>unpack(fmt, string)</code>  按照给定的格式(fmt)解析字节流string，返回解析出来的tuple。</li>
</ul>
</li>
<li><p><code>struct</code>中支持的格式如下表。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Format</th>
<th>C Type</th>
<th>Python</th>
<th>字节数</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>pad byte</td>
<td>no value</td>
<td>1</td>
</tr>
<tr>
<td>c</td>
<td>char</td>
<td>string of length 1</td>
<td>1</td>
</tr>
<tr>
<td>b</td>
<td>signed char</td>
<td>integer</td>
<td>1</td>
</tr>
<tr>
<td>B</td>
<td>unsigned char</td>
<td>integer</td>
<td>1</td>
</tr>
<tr>
<td>?</td>
<td>_Bool</td>
<td>bool</td>
<td>1</td>
</tr>
<tr>
<td>h</td>
<td>short</td>
<td>integer</td>
<td>2</td>
</tr>
<tr>
<td>H</td>
<td>unsigned short</td>
<td>integer</td>
<td>2</td>
</tr>
<tr>
<td>i</td>
<td>int</td>
<td>integer</td>
<td>4</td>
</tr>
<tr>
<td>I</td>
<td>unsigned int</td>
<td>integer or long</td>
<td>4</td>
</tr>
<tr>
<td>l</td>
<td>long</td>
<td>integer</td>
<td>4</td>
</tr>
<tr>
<td>L</td>
<td>unsigned long</td>
<td>long</td>
<td>4</td>
</tr>
<tr>
<td>q</td>
<td>long long</td>
<td>long</td>
<td>8</td>
</tr>
<tr>
<td>Q</td>
<td>unsigned long long</td>
<td>long</td>
<td>8</td>
</tr>
<tr>
<td>f</td>
<td>float</td>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>d</td>
<td>double</td>
<td>float</td>
<td>8</td>
</tr>
<tr>
<td>s</td>
<td>char[]</td>
<td>string</td>
<td>1</td>
</tr>
<tr>
<td>p</td>
<td>char[]</td>
<td>string</td>
<td>1</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/python/学习笔记_struct/" data-id="cj3326etz000xwgu164zl5fcf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python/学习笔记_itertools" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/python/学习笔记_itertools/" class="article-date">
  <time datetime="2017-05-24T14:01:50.880Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习笔记-itertools"><a href="#学习笔记-itertools" class="headerlink" title="学习笔记_itertools"></a>学习笔记_itertools</h1><p><em>学习日期：2016年10月11日</em><br><em>学习课程：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143200162233153835cfdd1a541a18ddc15059e3ddeec000" target="_blank" rel="external">itertools - 廖雪峰的官方网站</a></em></p>
<ul>
<li>Python的内建模块<code>itertools</code>提供了非常有用的用于操作迭代对象的函数。</li>
</ul>
<h2 id="无限迭代器"><a href="#无限迭代器" class="headerlink" title="无限迭代器"></a>无限迭代器</h2><ul>
<li><p><code>count(x, y)</code>      从x开始的整数循环器，每次增加y，如果不指定y则默认y为1</p>
</li>
<li><p><code>cycle(&#39;abc&#39;)</code>    重复序列的元素，既a, b, c, a, b, c …</p>
</li>
<li><p><code>repeat(x,y)</code>     重复x这个参数y次，如果不指定y即无限重复。</p>
</li>
<li><p>无限序列只有在<code>for</code>迭代时才会无限地迭代下去，如果只是创建了一个迭代对象，它不会事先把无限个元素生成出来，事实上也不可能在内存中创建无限多个元素。（迭代器）</p>
</li>
<li><p>无限序列虽然可以无限迭代下去，但是通常我们会通过<code>takewhile()</code>等函数根据条件判断来截取出一个有限的序列。</p>
</li>
<li><p>例子：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; natuals = itertools.count(1)</div><div class="line">&gt;&gt;&gt; ns = itertools.takewhile(lambda x: x &lt;= 10, natuals)</div><div class="line">&gt;&gt;&gt; list(ns)</div><div class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</div></pre></td></tr></table></figure>
<h2 id="chain"><a href="#chain" class="headerlink" title="chain()"></a>chain()</h2><ul>
<li>chain()可以把一组迭代对象串联起来，形成一个更大的迭代器。</li>
</ul>
<p>##groupby()</p>
<ul>
<li><p>groupby()把迭代器中相邻的重复元素挑出来放在一起。</p>
</li>
<li><p>实际上挑选规则是通过函数完成的（即第二个参数可以是函数），只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而函数返回值作为组的key。</p>
</li>
<li><p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; for key, group in itertools.groupby(&apos;AaaBBbcCAAa&apos;, lambda c: c.upper()):</div><div class="line">...     print(key, list(group))</div><div class="line">...</div><div class="line">A [&apos;A&apos;, &apos;a&apos;, &apos;a&apos;]</div><div class="line">B [&apos;B&apos;, &apos;B&apos;, &apos;b&apos;]</div><div class="line">C [&apos;c&apos;, &apos;C&apos;]</div><div class="line">A [&apos;A&apos;, &apos;A&apos;, &apos;a&apos;]</div></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/python/学习笔记_itertools/" data-id="cj3326etw000vwgu1motptfay" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python/学习笔记_hashlib" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/python/学习笔记_hashlib/" class="article-date">
  <time datetime="2017-05-24T14:01:50.850Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习笔记-hashlib"><a href="#学习笔记-hashlib" class="headerlink" title="学习笔记_hashlib"></a>学习笔记_hashlib</h1><p><em>学习日期：2016年10月11日</em><br><em>学习课程：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319556588648dd1fb0047a34d0c945ee33e8f4c90cc000" target="_blank" rel="external">hashlib - 廖雪峰的官方网站</a></em></p>
<h2 id="摘要算法简介"><a href="#摘要算法简介" class="headerlink" title="摘要算法简介"></a>摘要算法简介</h2><ul>
<li><p>Python的hashlib提供了常见的摘要算法，如MD5，SHA1等等。</p>
</li>
<li><p>摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。</p>
</li>
<li><p>我们以常见的摘要算法MD5为例，计算出一个字符串的MD5值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import hashlib</div><div class="line"></div><div class="line">md5 = hashlib.md5()</div><div class="line">md5.update(&apos;how to use md5 in python hashlib?&apos;.encode(&apos;utf-8&apos;))</div><div class="line">print(md5.hexdigest())</div><div class="line">#计算结果如下：</div><div class="line"></div><div class="line">d26a53750bc40b38b65a520292f69306</div></pre></td></tr></table></figure>
</li>
<li><p>如果数据量很大，可以分块多次调用<code>update()</code>，最后计算的结果是一样的。</p>
</li>
<li><p>另一种常见的摘要算法是SHA1，调用SHA1和调用MD5完全类似。</p>
</li>
<li><p>MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。</p>
</li>
<li>SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。</li>
</ul>
<p>##摘要算法应用</p>
<ul>
<li>储存用户的登陆密码。<ul>
<li>当用户登录时，首先计算用户输入的密码的MD5，然后和数据库存储的MD5对比，如果一致，说明口令输入正确，如果不一致，口令肯定错误。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/python/学习笔记_hashlib/" data-id="cj3326ety000wwgu119p90n63" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python/学习笔记_datetime" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/python/学习笔记_datetime/" class="article-date">
  <time datetime="2017-05-24T14:01:50.800Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习笔记-datetime"><a href="#学习笔记-datetime" class="headerlink" title="学习笔记_datetime"></a>学习笔记_datetime</h1><p><em>学习日期：2016年10月3日</em><br><em>学习课程：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431937554888869fb52b812243dda6103214cd61d0c2000" target="_blank" rel="external">datetime - 廖雪峰的官方网站</a></em></p>
<ul>
<li><code>datetime</code>是python中处理日期和时间的标准库</li>
</ul>
<p>##获取当前的时间</p>
<ul>
<li><p>注意到<code>datetime</code>是模块，<code>datetime</code>模块还包含一个<code>datetime</code>类，通过<code>from datetime import datetime</code>导入的才是<code>datetime</code>这个类。</p>
</li>
<li><p>如果仅导入<code>import datetime</code>，则必须引用全名<code>datetime.datetime</code>。</p>
</li>
<li><p><code>datetime.now()</code>返回当前日期和时间，其类型是<code>datetime</code>。</p>
</li>
</ul>
<p>##获取指定的日期和时间</p>
<ul>
<li>要指定某个日期和时间，我们直接用参数构造一个<code>datetime</code>类,例子如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> &gt;&gt;&gt; from datetime import datetime</div><div class="line">&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime</div><div class="line">&gt;&gt;&gt; print(dt)</div><div class="line">2015-04-19 12:20:00</div></pre></td></tr></table></figure>
<h2 id="datetime转化为timestamp"><a href="#datetime转化为timestamp" class="headerlink" title="datetime转化为timestamp"></a>datetime转化为timestamp</h2><ul>
<li><p><code>timestamp</code>的定义：</p>
<ul>
<li><p>在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为<code>0</code>（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为<code>timestamp</code>。</p>
</li>
<li><p>即<code>timestamp = 0 = 1970-1-1 00:00:00 UTC+0:00</code></p>
</li>
</ul>
</li>
<li><p><code>timestamp</code>与时区的值毫无关系，全球所有计算机中的<code>timestamp</code>的值都应该是相同的。</p>
</li>
<li><p>把一个<code>datetime</code>类型转化为<code>timestamp</code>只需要调用<code>timestamp()</code>方法。</p>
</li>
<li><p>注意Python的<code>timestamp</code>是一个浮点数(<code>float</code>类型)。如果有小数位，小数位表示毫秒数。</p>
</li>
</ul>
<p>##timestamp转化为datetime</p>
<ul>
<li><p>要把<code>timestamp</code>转换为<code>datetime</code>，使用<code>datetime</code>提供的<code>fromtimestamp()</code>方法</p>
</li>
<li><p><code>timestamp</code>是一个浮点数，它没有时区的概念，而<code>datetime</code>是有时区的。上述转换是在<code>timestamp</code>和本地时间做转换。本地时间是指当前操作系统设定的时区。</p>
</li>
<li><p><code>timestamp</code>也可以直接被转换到UTC标准时区(UTC+0:00)的时间，通过使用<code>datetime</code>提供的<code>utcfromtimestamp()</code>方法。</p>
</li>
</ul>
<h2 id="str转化为datetime"><a href="#str转化为datetime" class="headerlink" title="str转化为datetime"></a>str转化为datetime</h2><ul>
<li>转换方法是通过<code>datetime.strptime()</code>实现，需要一个日期和时间的格式化字符串。字符串<code>&#39;%Y-%m-%d %H:%M:%S&#39;</code>规定了日期和时间部分的格式。例子如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from datetime import datetime</div><div class="line">&gt;&gt;&gt; cday = datetime.strptime(&apos;2015-6-1 18:19:59&apos;, &apos;%Y-%m-%d %H:%M:%S&apos;)</div><div class="line">&gt;&gt;&gt; print(cday)</div><div class="line">2015-06-01 18:19:59</div></pre></td></tr></table></figure>
<ul>
<li>注意转换后的<code>datetime</code>是没有时区信息的。</li>
</ul>
<p>##datetime转化为str</p>
<ul>
<li>如果已经有了<code>datetime</code>对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过<code>strftime()</code>实现的，同样需要一个日期和时间的格式化字符串。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from datetime import datetime</div><div class="line">&gt;&gt;&gt; now = datetime.now()</div><div class="line">&gt;&gt;&gt; print(now.strftime(&apos;%a, %b %d %H:%M&apos;))</div><div class="line">Mon, May 05 16:28</div></pre></td></tr></table></figure>
<p>##datetime加减</p>
<ul>
<li>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类，使用timedelta你可以很容易地算出前几天和后几天的时刻。例子如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from datetime import datetime, timedelta</div><div class="line">&gt;&gt;&gt; now = datetime.now()</div><div class="line">&gt;&gt;&gt; now</div><div class="line">datetime.datetime(2015, 5, 18, 16, 57, 3, 540997)</div><div class="line">&gt;&gt;&gt; now + timedelta(hours=10)</div><div class="line">datetime.datetime(2015, 5, 19, 2, 57, 3, 540997)</div><div class="line">&gt;&gt;&gt; now - timedelta(days=1)</div><div class="line">datetime.datetime(2015, 5, 17, 16, 57, 3, 540997)</div><div class="line">&gt;&gt;&gt; now + timedelta(days=2, hours=12)</div><div class="line">datetime.datetime(2015, 5, 21, 4, 57, 3, 540997)</div></pre></td></tr></table></figure>
<p>##本地时间转化为UTC时间</p>
<ul>
<li><p>一个<code>datetime</code>类型有一个时区属性<code>tzinfo</code>，但是默认为<code>None</code>，所以无法区分这个<code>datetime</code>到底是哪个时区，除非强行给<code>datetime</code>设置一个时区。</p>
</li>
<li><p>设置时区分两步。</p>
<ul>
<li>第一步是用<code>timedelta()</code>创建时区</li>
<li>第二部是用<code>replace(tzinfo=刚才创建时区)</code>强制设置时区</li>
</ul>
</li>
</ul>
<p>##时区转换</p>
<ul>
<li>我们可以通过<code>utcnow()</code>拿到当前的UTC=0时间(例<code>utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)</code>)</li>
</ul>
<ul>
<li>利用带时区的<code>datetime</code>，通过<code>astimezone()</code>方法(例<code>bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))</code>)，可以转换到任意时区。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/python/学习笔记_datetime/" data-id="cj3326etv000uwgu1fwugjxoz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python/学习笔记_collections" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/python/学习笔记_collections/" class="article-date">
  <time datetime="2017-05-24T14:01:50.790Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习笔记-collections"><a href="#学习笔记-collections" class="headerlink" title="学习笔记_collections"></a>学习笔记_collections</h1><p><em>学习日期：2016年10月8日</em><br><em>学习课程：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431953239820157155d21c494e5786fce303f3018c86000" target="_blank" rel="external">collections - 廖雪峰的官方网站</a></em></p>
<ul>
<li><code>collections</code>是python内建的一个集合模块，提供了许多有用的集合类。</li>
</ul>
<p>##namedtuple</p>
<ul>
<li><p><code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定<code>了tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。</p>
</li>
<li><p>这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。</p>
</li>
</ul>
<p>##deque</p>
<ul>
<li><p><code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈。（因为list的插入和删除效率很低。</p>
</li>
<li><p><code>deque</code>除了实现<code>list</code>的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>
</li>
</ul>
<p>##defaultdict</p>
<ul>
<li><p>使用<code>dict</code>时，如果引用的<code>Key</code>不存在，就会抛出<code>KeyError</code>。如果希望<code>key</code>不存在时，返回一个默认值，就可以用<code>defaultdict</code>。</p>
</li>
<li><p>注意默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。</p>
</li>
<li><p>除了在Key不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p>
</li>
</ul>
<p>##OrderedDict</p>
<ul>
<li><p>使用<code>dict</code>时，<code>Key</code>是无序的。如果要保持<code>Key</code>的顺序，可以用<code>OrderedDict</code>。</p>
</li>
<li><p>注意，<code>OrderedDict</code>的<code>Key</code>会按照插入的顺序排列，不是<code>Key</code>本身排序。</p>
</li>
<li><p><code>OrderedDict</code>可以实现一个FIFO（先进先出）的<code>dict</code>，当容量超出限制时，先删除最早添加的Key。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">from collections import OrderedDict</div><div class="line"></div><div class="line">class LastUpdatedOrderedDict(OrderedDict):</div><div class="line"></div><div class="line">    def __init__(self, capacity):</div><div class="line">        super(LastUpdatedOrderedDict, self).__init__()</div><div class="line">        self._capacity = capacity</div><div class="line"></div><div class="line">    def __setitem__(self, key, value):</div><div class="line">        containsKey = 1 if key in self else 0</div><div class="line">        if len(self) - containsKey &gt;= self._capacity:</div><div class="line">            last = self.popitem(last=False)</div><div class="line">            print(&apos;remove:&apos;, last)</div><div class="line">        if containsKey:</div><div class="line">            del self[key]</div><div class="line">            print(&apos;set:&apos;, (key, value))</div><div class="line">        else:</div><div class="line">            print(&apos;add:&apos;, (key, value))</div><div class="line">        OrderedDict.__setitem__(self, key, value)</div></pre></td></tr></table></figure>
<p>##Counter</p>
<ul>
<li><p><code>Counter</code>是一个简单的计数器，例如，可以统计字符出现的个数。</p>
</li>
<li><p><code>Counter</code>实际上也是<code>dict</code>的一个子类。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/python/学习笔记_collections/" data-id="cj3326ett000twgu1j0l3z9uw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python/学习笔记_base64" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/python/学习笔记_base64/" class="article-date">
  <time datetime="2017-05-24T14:01:50.780Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习笔记-base64"><a href="#学习笔记-base64" class="headerlink" title="学习笔记_base64"></a>学习笔记_base64</h1><p><em>学习日期：2016年10月8日</em><br><em>学习课程：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431954588961d6b6f51000ca4279a3415ce14ed9d709000" target="_blank" rel="external">base64 - 廖雪峰的官方网站</a></em></p>
<ul>
<li><p>Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，Base64编码可用于在HTTP环境下传递较长的标识信息。</p>
</li>
<li><p>Python内置的base64可以直接进行base64的编解码。</p>
<ul>
<li>编码<code>base64.b64encode(\***)</code></li>
<li>解码<code>base64.b64decode(\***)</code></li>
</ul>
</li>
<li><p>Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。</p>
</li>
<li><p>如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用<code>\x00</code>字节在末尾补足后，再在编码的末尾加上1个或2个<code>=</code>号，表示补了多少字节，解码的时候，会自动去掉。</p>
</li>
<li><p>由于标准的Base64编码后可能出现字符<code>+</code>和<code>\</code>，在URL中就不能直接作为参数，所以又有一种”url safe”的base64编码，其实就是把字符<code>+</code>和<code>/</code>分别变成<code>-</code>和<code>_</code>。</p>
<ul>
<li><code>base64.urlsafe_b64encode()</code></li>
<li><code>bese64.urlsafe_b64decode()</code></li>
</ul>
</li>
<li><p>由于<code>=</code>字符也可能出现在Base64编码中，但<code>=</code>用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把=去掉。去掉<code>=</code>后怎么解码呢？因为Base64是把3个字节变为4个字节，所以，Base64编码的长度永远是4的倍数，因此，需要加上<code>=</code>把Base64字符串的长度变为4的倍数，就可以正常解码了。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/python/学习笔记_base64/" data-id="cj3326etk000rwgu1owaq380q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python/学习笔记_XML" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/python/学习笔记_XML/" class="article-date">
  <time datetime="2017-05-24T14:01:50.770Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习笔记-XML"><a href="#学习笔记-XML" class="headerlink" title="学习笔记_XML"></a>学习笔记_XML</h1><p><em>学习日期：2016年10月13日</em><br><em>学习课程：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432002075057b594f70ecb58445da6ef6071aca880af000" target="_blank" rel="external">XML - 廖雪峰的官方网站</a></em></p>
<ul>
<li><p>什么是 XML？</p>
<ul>
<li>XML 指可扩展标记语言（EXtensible Markup Language）。</li>
<li>XML 是一种很像HTML的标记语言。</li>
<li>XML 的设计宗旨是传输数据，而不是显示数据。</li>
<li>XML 标签没有被预定义。您需要自行定义标签。</li>
<li>XML 被设计为具有自我描述性。</li>
<li>XML 是 W3C 的推荐标准。</li>
</ul>
</li>
<li><p>XML 和 HTML 之间的差异</p>
<ul>
<li>XML 不是 HTML 的替代。</li>
<li>XML 和 HTML 为不同的目的而设计：</li>
<li><ul>
<li>XML 被设计用来传输和存储数据，其焦点是数据的内容。</li>
</ul>
</li>
<li><ul>
<li>HTML 被设计用来显示数据，其焦点是数据的外观。</li>
</ul>
</li>
<li>HTML 旨在显示信息，而 XML 旨在传输信息。<h2 id="解析字符串"><a href="#解析字符串" class="headerlink" title="解析字符串"></a>解析字符串</h2></li>
</ul>
</li>
<li><p>操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。</p>
</li>
<li><p>正常情况下，优先考虑SAX，因为DOM实在太占内存。</p>
</li>
<li><p>我们用一个例子来说明解析字符串（用SAX）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">from xml.parsers.expat import ParserCreate</div><div class="line"></div><div class="line">class DefaultSaxHandler(object):</div><div class="line">    def start_element(self, name, attrs):</div><div class="line">        print(&apos;sax:start_element: %s, attrs: %s&apos; % (name, str(attrs)))</div><div class="line"></div><div class="line">    def end_element(self, name):</div><div class="line">        print(&apos;sax:end_element: %s&apos; % name)</div><div class="line"></div><div class="line">    def char_data(self, text):</div><div class="line">        print(&apos;sax:char_data: %s&apos; % text)</div><div class="line"></div><div class="line">xml = r&apos;&apos;&apos;&lt;?xml version=&quot;1.0&quot;?&gt;</div><div class="line">&lt;ol&gt;</div><div class="line">    &lt;li&gt;&lt;a href=&quot;/python&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;</div><div class="line">    &lt;li&gt;&lt;a href=&quot;/ruby&quot;&gt;Ruby&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;/ol&gt;</div><div class="line">&apos;&apos;&apos;</div><div class="line"></div><div class="line">handler = DefaultSaxHandler()</div><div class="line">parser = ParserCreate()</div><div class="line">parser.StartElementHandler = handler.start_element</div><div class="line">parser.EndElementHandler = handler.end_element</div><div class="line">parser.CharacterDataHandler = handler.char_data</div><div class="line">parser.Parse(xml)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>输出如下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">sax:start_element: ol, attrs: &#123;&#125;</div><div class="line">sax:char_data: </div><div class="line"></div><div class="line">sax:char_data:     </div><div class="line">sax:start_element: li, attrs: &#123;&#125;</div><div class="line">sax:start_element: a, attrs: &#123;&apos;href&apos;: &apos;/python&apos;&#125;</div><div class="line">sax:char_data: Python</div><div class="line">sax:end_element: a</div><div class="line">sax:end_element: li</div><div class="line">sax:char_data: </div><div class="line"></div><div class="line">sax:char_data:     </div><div class="line">sax:start_element: li, attrs: &#123;&#125;</div><div class="line">sax:start_element: a, attrs: &#123;&apos;href&apos;: &apos;/ruby&apos;&#125;</div><div class="line">sax:char_data: Ruby</div><div class="line">sax:end_element: a</div><div class="line">sax:end_element: li</div><div class="line">sax:char_data: </div><div class="line"></div><div class="line">sax:end_element: ol</div></pre></td></tr></table></figure></p>
<p>##生成XML</p>
<ul>
<li>最简单也是最有效的生成XML的方法是拼接字符串，例子如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">L = []</div><div class="line">L.append(r&apos;&lt;?xml version=&quot;1.0&quot;?&gt;&apos;)</div><div class="line">L.append(r&apos;&lt;root&gt;&apos;)</div><div class="line">L.append(encode(&apos;some &amp; data&apos;))</div><div class="line">L.append(r&apos;&lt;/root&gt;&apos;)</div><div class="line">return &apos;&apos;.join(L)</div></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/python/学习笔记_XML/" data-id="cj3326etf000pwgu1r7xruykm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python/学习笔记_ThreadLocal" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/python/学习笔记_ThreadLocal/" class="article-date">
  <time datetime="2017-05-24T14:01:50.760Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习笔记-ThreadLocal"><a href="#学习笔记-ThreadLocal" class="headerlink" title="学习笔记_ThreadLocal"></a>学习笔记_ThreadLocal</h1><p><em>学习日期：2016年10月1日</em><br><em>学习课程：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431928972981094a382e5584413fa040b46d46cce48e000" target="_blank" rel="external">ThreadLocal - 廖雪峰的官方网站</a></em></p>
<ul>
<li><p>在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦。</p>
</li>
<li><p>一个<code>ThreadLocal</code>变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。<code>ThreadLocal</code>解决了参数在一个线程中各个函数之间互相传递的问题。</p>
</li>
<li><p><code>ThreadLocal</code>最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/python/学习笔记_ThreadLocal/" data-id="cj3326eto000swgu10qlt202j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python/学习笔记_StringIO和BytesIO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/python/学习笔记_StringIO和BytesIO/" class="article-date">
  <time datetime="2017-05-24T14:01:50.740Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习笔记-StringIO和BytesIO"><a href="#学习笔记-StringIO和BytesIO" class="headerlink" title="学习笔记_StringIO和BytesIO"></a>学习笔记_StringIO和BytesIO</h1><p><em>学习日期：2016年9月29日</em><br><em>学习课程：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431918785710e86a1a120ce04925bae155012c7fc71e000" target="_blank" rel="external">StringIO和BytesIO - 廖雪峰的官方网站</a></em></p>
<p>##StringIO</p>
<ul>
<li><p><code>StringIO</code>顾名思义就是在内存中读写<code>str</code>。</p>
</li>
<li><p>要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可。</p>
</li>
<li><p><code>getvalue()</code>方法用于获得写入后的str。</p>
</li>
<li><p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取。</p>
</li>
</ul>
<p>##BytesIO</p>
<ul>
<li><p>StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。BytesIO实现了在内存中读写bytes。</p>
</li>
<li><p>和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/python/学习笔记_StringIO和BytesIO/" data-id="cj3326et6000nwgu1dyfszqm4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python/学习笔记_IO编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/python/学习笔记_IO编程/" class="article-date">
  <time datetime="2017-05-24T14:01:50.720Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习笔记-IO编程"><a href="#学习笔记-IO编程" class="headerlink" title="学习笔记_IO编程"></a>学习笔记_IO编程</h1><p><em>学习日期：2016年9月29日</em><br><em>学习课程：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431917590955542f9ac5f5c1479faf787ff2b028ab47000" target="_blank" rel="external">IO编程 - 廖雪峰的官方网站</a></em></p>
<ul>
<li><p>IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。</p>
</li>
<li><p>IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对</p>
</li>
<li><p>IO编程又分为同步IO和异步IO，我们本章讨论的都是同步IO，异步IO性能比同步IO好很多，但是比较复杂，后续涉及到服务器端开发时候再讨论。</p>
<ul>
<li>同步IO：程序执行到IO时，暂停后续代码，等数据读写完毕，再继续执行后续代码。</li>
<li>异步IO：程序执行到IO时，后续代码可以继续执行，不用等待数据读写完毕。</li>
</ul>
</li>
</ul>
<p>##读写</p>
<p>###文档读写</p>
<ul>
<li>在python中，文档读写是通过<code>open()</code>加不同的标识符实现的，要注意在操作文档读写时使用with语句的好习惯。</li>
</ul>
<h3 id="StringIO和BytesIO"><a href="#StringIO和BytesIO" class="headerlink" title="StringIO和BytesIO"></a>StringIO和BytesIO</h3><ul>
<li><p><code>StringIO</code>和<code>BytesIO</code>本质上是两个class类，我们要读写它们还是要是用<code>write()</code>方法。</p>
</li>
<li><p><code>StringIO</code>和<code>BytesIO</code>是在内存中操作<code>str</code>和<code>bytes</code>的方法，使得和读写文件具有一致的接口。</p>
</li>
</ul>
<p>##操作文件和目录</p>
<ul>
<li>Python的<code>os</code>模块封装了操作系统的目录和文件操作，要注意这些函数有的在<code>os</code>模块中，有的在<code>os.path</code>模块中。</li>
</ul>
<p>##序列化</p>
<ul>
<li><p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling。</p>
</li>
<li><p>把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>
</li>
<li><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。<strong>捡重点说！JSON就是一个标准的格式，便于在各个编程语言之间交流和传递对象</strong></p>
</li>
<li><p>Python语言特定的序列化模块是<code>pickle</code>，但如果要把序列化搞得更通用、更符合Web标准，就可以使用<code>json</code>模块。</p>
</li>
<li><p>json模块的<code>dumps()</code>和<code>loads()</code>函数是定义得非常好的接口的典范。当我们使用时，只需要传入一个必须的参数。但是，当默认的序列化或反序列机制不满足我们的要求时，我们又可以传入更多的参数来定制序列化或反序列化的规则，既做到了接口简单易用，又做到了充分的扩展性和灵活性。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/python/学习笔记_IO编程/" data-id="cj3326et5000mwgu1hl35fvu1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/24/webpack/webpack学习笔记 （下）/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/05/24/vuex/Vuex的五个核心属性/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/05/24/webpack/webpack学习笔记 （上）/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/05/24/python/python中的元类Metaclass/python中的元类Metaclass/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/05/24/python/获取对象信息/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>